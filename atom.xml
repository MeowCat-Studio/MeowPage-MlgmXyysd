<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>MlgmXyysd 的猫窝</title>
  
  <subtitle>欢迎来猫窝，喵。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://mlgmxyysd.meowcat.org/"/>
  <updated>2020-09-06T00:27:47.070Z</updated>
  <id>http://mlgmxyysd.meowcat.org/</id>
  
  <author>
    <name>MlgmXyysd</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android Code Search by Google</title>
    <link href="http://mlgmxyysd.meowcat.org/2020/03/25/android-code-search-google/"/>
    <id>http://mlgmxyysd.meowcat.org/2020/03/25/android-code-search-google/</id>
    <published>2020-03-25T02:28:18.000Z</published>
    <updated>2020-09-06T00:27:47.070Z</updated>
    
    <content type="html"><![CDATA[<p>查阅 Android 源代码一直都是 Android 相关开发者亘古不变的需求</p><p>以往查看源代码的时候需要通过将源码下载到本地或查阅一些在线的 xref 网站，而这些方法都对开发者很不友好：</p><p>Android 源码非常大，并且因为一些众所周知的原因，下载速度也非常慢</p><p>xref 网站的搜索功能极其垃圾，在打开比较大的源码文件时还经常会卡死浏览器</p><a id="more"></a><p>Google 终于在去年年底推出了官方的代码查阅平台：<a href="https://cs.android.com/">Android Code Search</a> (梯)</p><p><img src="/2020/03/25/android-code-search-google/cs.png" alt></p><p>官方介绍：</p><p>Android 代码搜索是一款可帮助开发者查看实际使用的 Android 源代码的工具。<br>利用代码搜索，您可以点击源代码的一部分到另一部分，从而更轻松地在所有 AOSP 中浏览交叉引用。这有助于您在 Android 的开源分支之间切换。只有主分支在 Java 和 CPP 中有交叉引用信息，而 Go 则没有。</p><p>除了搜索 Android 项目的代码之外，该代码搜索工具还同时提供了 AndroidX 库的源代码码搜索。</p><p>更多说明请查阅：<a href="https://source.android.google.cn/setup/contribute/code-search">Link</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;查阅 Android 源代码一直都是 Android 相关开发者亘古不变的需求&lt;/p&gt;
&lt;p&gt;以往查看源代码的时候需要通过将源码下载到本地或查阅一些在线的 xref 网站，而这些方法都对开发者很不友好：&lt;/p&gt;
&lt;p&gt;Android 源码非常大，并且因为一些众所周知的原因，下载速度也非常慢&lt;/p&gt;
&lt;p&gt;xref 网站的搜索功能极其垃圾，在打开比较大的源码文件时还经常会卡死浏览器&lt;/p&gt;
    
    </summary>
    
    
      <category term="随笔" scheme="http://mlgmxyysd.meowcat.org/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="原创" scheme="http://mlgmxyysd.meowcat.org/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="Android" scheme="http://mlgmxyysd.meowcat.org/tags/Android/"/>
    
      <category term="技术笔记" scheme="http://mlgmxyysd.meowcat.org/tags/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>树莓派使用官方 64 位 Raspbian 系统</title>
    <link href="http://mlgmxyysd.meowcat.org/2020/03/09/raspberry-pi-64-bit/"/>
    <id>http://mlgmxyysd.meowcat.org/2020/03/09/raspberry-pi-64-bit/</id>
    <published>2020-03-09T09:42:45.000Z</published>
    <updated>2020-09-06T03:36:45.529Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.raspberrypi.org/">树莓派</a> 是一个价格实惠（大概吧）的开发板，目前已经出到了第4代。就硬件性能上来说，树莓派4已经达到了办公级别<br><img src="/2020/03/09/raspberry-pi-64-bit/pi.png" alt></p><p>但是，32 位的 Raspbian 系统严重拖了 Raspberry Pi 4B 的后腿</p><a id="more"></a><p>实际上，官方已经在最新的 Raspbian 上更新了 arm64 的内核，如果你的型号在下面的表格中，都可以使用 armv8(arm64) 的内核来提升性能</p><table><thead><tr><th align="center">型号</th><th align="center">版本</th><th align="center">处理器</th></tr></thead><tbody><tr><td align="center">Raspberry Pi 4B</td><td align="center">-</td><td align="center">Broadcom BCM2711, Quad core ARM Cortex-A72 (ARM v8) 64-bit SoC @ 1.5GHz</td></tr><tr><td align="center">Raspberry Pi 3B+</td><td align="center">-</td><td align="center">Broadcom BCM2837B0, Quad core ARM Cortex-A53 (ARM v8) 64-bit SoC @ 1.4GHz</td></tr><tr><td align="center">Raspberry Pi 3A+</td><td align="center">-</td><td align="center">Broadcom BCM2837B0, Quad core ARM Cortex-A53 (ARM v8) 64-bit SoC @ 1.4GHz</td></tr><tr><td align="center">Raspberry Pi 3B</td><td align="center">-</td><td align="center">Broadcom BCM2837, Quad core ARM Cortex-A53 (ARM v8) 64-bit SoC @ 1.2GHz</td></tr><tr><td align="center">Raspberry Pi 2B</td><td align="center">rev1.2</td><td align="center">Broadcom BCM2837, Quad core ARM Cortex-A53 (ARM v8) 64-bit SoC @ 1.2GHz</td></tr></tbody></table><p>首先先检查一下 <code>/boot</code>(FAT32分区) 中是否有 <code>kernel8.img</code>，如果没有，请先运行 <code>sudo rpi-update</code> 更新至最新版系统或 <a href="https://www.raspberrypi.org/downloads/raspbian/">下载最新系统镜像</a><br><img src="/2020/03/09/raspberry-pi-64-bit/kernel.png" alt></p><p>如果有，打开 <code>config.txt</code>，将 <code>arm_64bit</code> 的值修改为 <code>1</code>(一般是在文件末尾添加 <code>arm_64bit=1</code>)</p><blockquote><p><a href="https://www.raspberrypi.org/documentation/configuration/config-txt/boot.md">官方文档</a><br><strong>arm_64bit</strong><br>If set to non-zero, forces the kernel loading system to assume a 64-bit kernel, starts the processors up in 64-bit mode, and sets kernel8.img to be the kernel image loaded, unless there is an explicit kernel option defined in which case that is used instead. Defaults to 0 on all platforms. NOTE: 64-bit kernels must be uncompressed image files.<br><br>Note that the 64-bit kernel will only work on the Pi4, Pi3, and Pi2B rev1.2 boards with latest firmware.<br><br>如果设置为非零，则强制内核加载系统采用64位内核，以64位模式启动处理器，并将 kernel8.img 设置为加载的内核映像，除非在这种情况下定义了显式 kernel 选项，否则将使用该选项。在所有平台上默认为0。注意：64位内核必须是未压缩的镜像文件<br><br>注：64位内核只能在具有最新固件的 Pi4, Pi3和Pi2B rev1.2 开发板工作。</p></blockquote><p>保存，重启</p><p><img src="/2020/03/09/raspberry-pi-64-bit/shell.png" alt></p><p>内核已经变成了 aarch64，现在可以运行 arm64 架构的程序了，大功告成！</p><hr><p>2020.6.1 更新：</p><p>树莓派官方已经在5月28日发布2020-05-27版的arm64<strong>测试版</strong>镜像，但实测下来许多软件包都没有适配，期待树莓派真正arm64的那一天</p><p><a href="https://www.raspberrypi.org/forums/viewtopic.php?f=117&t=275370">官方论坛</a></p><p><a href="https://downloads.raspberrypi.org/raspios_arm64/images/raspios_arm64-2020-05-28/2020-05-27-raspios-buster-arm64.zip">镜像下载</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://www.raspberrypi.org/&quot;&gt;树莓派&lt;/a&gt; 是一个价格实惠（大概吧）的开发板，目前已经出到了第4代。就硬件性能上来说，树莓派4已经达到了办公级别&lt;br&gt;&lt;img src=&quot;/2020/03/09/raspberry-pi-64-bit/pi.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;但是，32 位的 Raspbian 系统严重拖了 Raspberry Pi 4B 的后腿&lt;/p&gt;
    
    </summary>
    
    
      <category term="随笔" scheme="http://mlgmxyysd.meowcat.org/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="原创" scheme="http://mlgmxyysd.meowcat.org/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="技术笔记" scheme="http://mlgmxyysd.meowcat.org/tags/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>浅谈 Xposed 新概念 [模块作用域]</title>
    <link href="http://mlgmxyysd.meowcat.org/2019/12/28/xposed-modules-activation-scope/"/>
    <id>http://mlgmxyysd.meowcat.org/2019/12/28/xposed-modules-activation-scope/</id>
    <published>2019-12-28T06:37:08.000Z</published>
    <updated>2020-09-06T03:36:45.531Z</updated>
    
    <content type="html"><![CDATA[<p>众所周知，Xposed 是一个系统级别的软件框架，它与 Cydia Substrate 不同，Xposed 仅可 hook app_process 中的 java 函数，不过对于大部分的 Android 应用来说已经足够了；</p><p>它所提供的 API 可以供模块开发者在不修改目标应用字节码的前提下修改目标应用的行为，甚至是将自定义的代码注入进目标应用中，由目标应用代为执行。</p><a id="more"></a><p>Xposed 模块开发起来也非常简单，简单来说，获取目标应用的源码或者反编译出伪代码，找到目标方法，将相关逻辑写入模块，编译，完成。</p><p>于是，一种新的安全风险也随之出现了</p><blockquote><p>某“步数模块”对 [淘宝] 应用插入淘口令<br>某“后台管理模块”做了一堆根本不应该它去做的功能<br>某“[抖音] 模块”影响 [微信] 功能<br>……</p></blockquote><p>更有甚者利用 [微信] 的公众号功能，为自己的帖子刷流量</p><p>而当你想要禁止掉这种滥用行为的时候，你会发现，也许它根本就没有申请正常情况下做这些事情需要的权限，更别谈禁止了</p><p>这是因为它将代码注入到了 [微信] 应用中，所有的工作都是由 [微信] 来完成的，如果你使用抓包软件来抓取流量包的话，你会发现所有的相关流量都是由 [微信] 发送和接收的</p><p>应该庆幸的是，目前所抓到类似行为的模块都是使用 java （或 kotlin 等 jvm 语言）层来编写的，反编译还算比较容易</p><p>可是如果模块使用 native（C/C++）层编写（据我所知已经有一些模块使用 native 层来编写），或者使用了一堆非常恶心人的加固/混淆呢？</p><p>要求所有模块必须开源一定是不可能的事情，第一这会大大打击模块开发者的积极性，第二即使开源也不能确保一定是安全的</p><p>（更何况某个自诩“安全”的 Xposed 框架商业化分支也还是闭源的，何谈模块开源？）</p><p>我相信 Xposed 的作者 rovo89 （等一下，Xposed 停更的最后一个版本号是 89，我好像发现了什么 zzz ）一定也注意到了这个问题，只是因为某些原因最终弃坑掉了整个 Xposed 项目</p><p>于是，我们提出了一个新的概念</p><p>我将它称为</p><p><strong>[模块作用域] (Modules Activation Scope)</strong></p><ul><li>它能做什么？</li></ul><p>简单来说，用户可以自主选择某个模块只对某些应用生效（或某个应用只激活某些模块，这个根据不同 Xposed 框架分支开发者的喜好自由安排）</p><p>这样虽说不可能完全解决 Xposed 模块滥用行为的安全问题，至少可以防止 Xposed 模块跨域对非目标应用进行 hook 操作</p><ul><li>如何才能用上这一功能？</li></ul><p>当前已经有多种 Xposed 框架分支的开发者响应了这一概念</p><p>EdXposed 此功能正在开发中</p><p>（已编辑）梦境 DreamLand 已发布</p><p>（已编辑）应用转生 已发布</p><p>还有其他分支未收集</p><p>用户需要做的就是等待当前使用的分支更新这一功能</p><p>同时，我修改了开源分支 XPatch 的代码以支持这一功能，高级用户可以尝试使用一下</p><p>演示视频： <a href="https://www.bilibili.com/video/av80958793">https://www.bilibili.com/video/av80958793</a></p><p>源代码（已修改）： <a href="https://github.com/MlgmXyysd/xposed_module_loader">https://github.com/MlgmXyysd/xposed_module_loader</a></p><ul><li>（ DEV ）模块开发者需要特殊适配这一功能吗？</li></ul><p>不需要</p><p>模块作用域是面向于用户层面的功能，模块开发者不需要也不应该特殊适配或滥用这项功能</p><p>为 Xposed 框架分支添加新功能一定应该是建立在兼容原版 API 的基础上的（当然某个 Xposed 分支妄图分裂 Xposed 生态从而创建自己由 Xposed API 魔改而来的 TxxCxx API 我是不敢恭维，也不想在这里过多提及）</p><p>模块开发者唯一需要做的就是告知用户你的模块 hook 了哪个应用的包名，供用户来参考</p><ul><li>（ DEV ）我该如何为我的框架分支添加这一功能？</li></ul><p>为单独的应用存储模块列表（推荐使用目标应用包名作为标识符），并设立全局列表（无法读取当前应用的列表时可读取全局列表）</p><p>具体代码自行实现</p><ul><li>（ DEV ）为什么不像 Android 软件在 Manifest 中声明权限那样要求模块声明 hook 列表？</li></ul><p>在上文中我提到了兼容性</p><p>除此之外，要求模块适配自己的 API 同样是一种不可能的行为</p><p>一味的要求开发者适配自己的 API 会导致对其他 Xposed 框架分支的兼容性下降，或者同时兼容多个分支的难度上升<br>同时，保留原版 Xposed API 也是对 Xposed 原开发者 rovo89 的一种尊重</p><p>换一种问法，框架完全可以做到的事情为什么非要模块开发者来做呢？</p><hr><p>这一概念经过测试完全是可行的（已有经由 XPatch 修改的 demo 测试成功，见上文）</p><p>但是，概念也有它本身的一个漏洞，它仅封堵掉了模块对于跨域应用的滥用行为，并没有从根本上杜绝滥用行为的发生（如，针对正常的目标应用的滥用行为），用户在选择模块时仍需谨慎</p><hr><p>我是 MlgmXyysd，希望更多 Xposed 框架分支可以响应这一概念，同时也希望更多的开发者可以开发出自己的 Xposed 框架开源分支</p><hr><p>（已编辑）附件：</p><blockquote><p>目前已知的几种 Xposed 实现方案的「作者是个人还是公司、是否开源、是否商业化」的总结</p><p>鉴于阻止运行的前车之鉴「 2.3.2 之后（不含 2.3.2 ）的阻止运行你敢用嘛？」（ From @LetITFlyW ） </p><p>如果你没为服务付钱，那可能你就是产品。免费商业化比收费商业化更可怕。建议各位有使用 Xposed 的需求的朋友在条件适宜的情况下拥抱开源或者虽闭源但非商业化的实现方案。另：在任何情况下均不建议关注「某个 Xposed 实现方案的作者」的「推送过多次广告文章」的微信公众号。</p></blockquote><p><img src="/2019/12/28/xposed-modules-activation-scope/compare.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;众所周知，Xposed 是一个系统级别的软件框架，它与 Cydia Substrate 不同，Xposed 仅可 hook app_process 中的 java 函数，不过对于大部分的 Android 应用来说已经足够了；&lt;/p&gt;
&lt;p&gt;它所提供的 API 可以供模块开发者在不修改目标应用字节码的前提下修改目标应用的行为，甚至是将自定义的代码注入进目标应用中，由目标应用代为执行。&lt;/p&gt;
    
    </summary>
    
    
      <category term="随笔" scheme="http://mlgmxyysd.meowcat.org/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="原创" scheme="http://mlgmxyysd.meowcat.org/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="Android" scheme="http://mlgmxyysd.meowcat.org/tags/Android/"/>
    
      <category term="技术笔记" scheme="http://mlgmxyysd.meowcat.org/tags/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Xposed" scheme="http://mlgmxyysd.meowcat.org/tags/Xposed/"/>
    
  </entry>
  
  <entry>
    <title>找到了合适的 Xposed 框架</title>
    <link href="http://mlgmxyysd.meowcat.org/2019/12/20/xpatch-found/"/>
    <id>http://mlgmxyysd.meowcat.org/2019/12/20/xpatch-found/</id>
    <published>2019-12-20T01:07:51.000Z</published>
    <updated>2020-09-06T00:27:47.075Z</updated>
    
    <content type="html"><![CDATA[<p>最近发现了一个新的（貌似是我火星了）开源 Xposed 框架：</p><p><a href="https://windysha.github.io/2019/04/18/Xpatch-%E5%85%8DRoot%E5%AE%9E%E7%8E%B0App%E5%8A%A0%E8%BD%BDXposed%E6%8F%92%E4%BB%B6%E7%9A%84%E4%B8%80%E7%A7%8D%E6%96%B9%E6%A1%88/">Xpatch: 免Root实现App加载Xposed插件的一种方案</a></p><a id="more"></a><p>源码: <a href="https://github.com/WindySha/Xpatch">https://github.com/WindySha/Xpatch</a></p><p>和众多免 root 的 Xposed 框架原理类似，都是在 App 中插入 Appllication，让 App 在运行时执行加载模块的操作，需要修改 app</p><p>加载模块的源码：<a href="https://github.com/WindySha/xposed_module_loader">https://github.com/WindySha/xposed_module_loader</a></p><p>这样一来就可以开搞之前说的那个”<a href="http://mlgmxyysd.meowcat.org/2019/11/02/new-xposed-security-problem/">安全问题</a>“了</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近发现了一个新的（貌似是我火星了）开源 Xposed 框架：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://windysha.github.io/2019/04/18/Xpatch-%E5%85%8DRoot%E5%AE%9E%E7%8E%B0App%E5%8A%A0%E8%BD%BDXposed%E6%8F%92%E4%BB%B6%E7%9A%84%E4%B8%80%E7%A7%8D%E6%96%B9%E6%A1%88/&quot;&gt;Xpatch: 免Root实现App加载Xposed插件的一种方案&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="随笔" scheme="http://mlgmxyysd.meowcat.org/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="原创" scheme="http://mlgmxyysd.meowcat.org/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="Android" scheme="http://mlgmxyysd.meowcat.org/tags/Android/"/>
    
      <category term="技术笔记" scheme="http://mlgmxyysd.meowcat.org/tags/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Xposed" scheme="http://mlgmxyysd.meowcat.org/tags/Xposed/"/>
    
  </entry>
  
  <entry>
    <title>Xposed 框架中新的安全问题</title>
    <link href="http://mlgmxyysd.meowcat.org/2019/11/02/new-xposed-security-problem/"/>
    <id>http://mlgmxyysd.meowcat.org/2019/11/02/new-xposed-security-problem/</id>
    <published>2019-11-02T04:25:43.000Z</published>
    <updated>2020-09-06T03:36:45.528Z</updated>
    
    <content type="html"><![CDATA[<p>找到了一个 Xposed 中的模块安全问题，理论上可以堵住一部分，就不在 EdXposed 上改了（怕爆炸），接下来要找个合适的侵入性小的开源 Xposed 框架来试着搞一下</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;找到了一个 Xposed 中的模块安全问题，理论上可以堵住一部分，就不在 EdXposed 上改了（怕爆炸），接下来要找个合适的侵入性小的开源 Xposed 框架来试着搞一下&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="随笔" scheme="http://mlgmxyysd.meowcat.org/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="原创" scheme="http://mlgmxyysd.meowcat.org/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="Android" scheme="http://mlgmxyysd.meowcat.org/tags/Android/"/>
    
      <category term="技术笔记" scheme="http://mlgmxyysd.meowcat.org/tags/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Xposed" scheme="http://mlgmxyysd.meowcat.org/tags/Xposed/"/>
    
  </entry>
  
  <entry>
    <title>Qin 1s+ 玩机研究</title>
    <link href="http://mlgmxyysd.meowcat.org/2019/09/14/Qin-1sp-research/"/>
    <id>http://mlgmxyysd.meowcat.org/2019/09/14/Qin-1sp-research/</id>
    <published>2019-09-14T07:29:52.000Z</published>
    <updated>2020-09-06T00:27:46.555Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近看见了这个多亲1s+按键机，心血来潮弄个玩玩，第三天的下午快递送来了<br><img src="/2019/09/14/Qin-1sp-research/1.jpg" alt></p><a id="more"></a><p>这玩意开机速度很快，让我想起了AIPC（雾），也没有开机音乐<br><img src="/2019/09/14/Qin-1sp-research/2.jpg" alt><br>比几年前的挪鸡鸭按键机开机快<br><img src="/2019/09/14/Qin-1sp-research/3.jpg" alt><br>进系统设置里看，mocor系统，还行<br><img src="/2019/09/14/Qin-1sp-research/4.jpg" alt><br>随便翻翻，有个浏览器<br><img src="/2019/09/14/Qin-1sp-research/5.jpg" alt><br>进去一看我就懵了，这特么的不就是安卓么？<br><img src="/2019/09/14/Qin-1sp-research/6.jpg" alt><br>好吧那就装个酷安耍耍#(滑稽)<br>连网，下载，一气呵成<br>点击安装包安装。。。<br>你特么在逗我？？？<br><img src="/2019/09/14/Qin-1sp-research/7.jpg" alt><br>行吧，这sdk是有多低啊。。<br>还好我保留了老版本的酷市场apk，放进sd卡，插入手机，准备安装<br>结果。。。<br>这玩意特么的连文件管理都没有？？？</p><h2 id="开启USB调试"><a href="#开启USB调试" class="headerlink" title="开启USB调试"></a>开启USB调试</h2><p>行⑧，我用adb，不过这玩意咋开启usb调试来着？设置里几个版本号按了半天也没见弹出来开发者选项啊<br>查了一番资料得知这手机是展讯cpu<br>丢上展讯工程模式代码<code>*#*#83781#*#*</code><br><img src="/2019/09/14/Qin-1sp-research/8.jpg" alt><br>诶嘿嘿，进去了<br><img src="/2019/09/14/Qin-1sp-research/9.jpg" alt><br>翻了一下发现第二个tab有个<code>Allow Debug</code>，有些可疑，打开瞅瞅<br><img src="/2019/09/14/Qin-1sp-research/10.jpg" alt><br>再回去关于手机界面发现出来了一堆东西，点击版本号也出现了开发者选项<br><img src="/2019/09/14/Qin-1sp-research/11.jpg" alt><br><img src="/2019/09/14/Qin-1sp-research/12.jpg" alt><br><img src="/2019/09/14/Qin-1sp-research/13.jpg" alt><br>调试整开<br><img src="/2019/09/14/Qin-1sp-research/14.jpg" alt><br><img src="/2019/09/14/Qin-1sp-research/15.jpg" alt><br>通知栏出来了调试的图标<br><img src="/2019/09/14/Qin-1sp-research/16.jpg" alt><br>看这图标。。特么的KitKat？怪不得装不上<br>看一下设备列表<br><img src="/2019/09/14/Qin-1sp-research/17.png" alt><br>wtf？<br><img src="/2019/09/14/Qin-1sp-research/18.png" alt><br>原来Windows没有自带展讯机子的驱动，还得自己找</p><h2 id="驱动安装"><a href="#驱动安装" class="headerlink" title="驱动安装"></a>驱动安装</h2><p>找了半天之后，点击安装，吃口月饼，差点喷出来<br><img src="/2019/09/14/Qin-1sp-research/19.png" alt><br>全 员 失 败<br>看安装日志发现是catalog签名问题<br><img src="/2019/09/14/Qin-1sp-research/20.png" alt><br>那就好办了，把驱动签名禁用就行<br>进入<code>设置--更新和安全--恢复--高级启动--立即重新启动</code><br><img src="/2019/09/14/Qin-1sp-research/21.png" alt><br>然后点<code>疑难解答--高级选项--启动设置--重启</code><br><img src="/2019/09/14/Qin-1sp-research/22.jpg" alt><br><img src="/2019/09/14/Qin-1sp-research/23.jpg" alt><br><img src="/2019/09/14/Qin-1sp-research/24.jpg" alt><br><img src="/2019/09/14/Qin-1sp-research/25.jpg" alt><br>按下F7或者7<br><img src="/2019/09/14/Qin-1sp-research/26.jpg" alt><br>然后进入系统，重新安装驱动，弹出来了确认框<br><img src="/2019/09/14/Qin-1sp-research/27.png" alt><br>安装成功<br><img src="/2019/09/14/Qin-1sp-research/28.png" alt><br>再次查看设备列表，已经显示出来了<br><img src="/2019/09/14/Qin-1sp-research/29.png" alt><br>安装应用<br><img src="/2019/09/14/Qin-1sp-research/30.png" alt><br>我屮艸芔茻<br><code>INSTALL_FAILED_APK_RESTRICTED</code><br>系统里某个软件拒绝了安装<br>看来想安装软件还得破解系统的限制</p><h2 id="失败的一次尝试"><a href="#失败的一次尝试" class="headerlink" title="失败的一次尝试"></a>失败的一次尝试</h2><p>用adb把build.prop扒到本地</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ adb pull /system/build.prop</span><br></pre></td></tr></table></figure><p>通过翻阅build.prop，找到了一处可疑点<br>第72行，<code>ro.sys.appinstallwhitelist</code><br>app安装白名单，应该就是这个东西了<br><img src="/2019/09/14/Qin-1sp-research/31.png" alt><br>我们给他改成false，再通过rec刷进去试试（万一rec没有签名验证岂不是美滋滋？）<br><img src="/2019/09/14/Qin-1sp-research/32.png" alt><br>写一个刷机脚本，放在<code>META-INF/com/google/android/updater-script</code><br><img src="/2019/09/14/Qin-1sp-research/33.png" alt><br><img src="/2019/09/14/Qin-1sp-research/34.png" alt><br>最后压缩成zip<br><img src="/2019/09/14/Qin-1sp-research/35.png" alt><br>重启进入Recovery模式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ adb reboot recovery</span><br></pre></td></tr></table></figure><p><img src="/2019/09/14/Qin-1sp-research/36.jpg" alt><br>这。。是出错了么。。<br>对着按键随便按了一通之后，发现按下键盘的“8”键可以显示<br><img src="/2019/09/14/Qin-1sp-research/37.jpg" alt><br>诶，这rec有sideload模式（apply update from ADB）<br><img src="/2019/09/14/Qin-1sp-research/38.jpg" alt><br>安装试试</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ adb sideload update.zip</span><br></pre></td></tr></table></figure><p><img src="/2019/09/14/Qin-1sp-research/39.png" alt><br>发现无论如何都连接不上设备，还是老老实实扔进sd卡吧<br>从sd卡安装<br>欧豁，有签名验证，我们要先破解下Recovery<br><img src="/2019/09/14/Qin-1sp-research/40.jpg" alt></p><h2 id="提取Recovery镜像"><a href="#提取Recovery镜像" class="headerlink" title="提取Recovery镜像"></a>提取Recovery镜像</h2><p>破解Recovery首先需要获取recovery.img，一般是在系统更新的包里<br>用Fiddler抓一下系统更新的包<br>打开Fiddler，勾选<code>Tools--Options--Connections--Allow remote computers to connect</code><br><img src="/2019/09/14/Qin-1sp-research/41.png" alt><br>弹出对话框，大意是让你手动重启Fiddler，点击确定<br><img src="/2019/09/14/Qin-1sp-research/42.png" alt><br>然后重启Fiddler，手机连接wifi，代理填你电脑ip，端口默认填8888</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ipconfig</span><br></pre></td></tr></table></figure><p>获取电脑ip<br><img src="/2019/09/14/Qin-1sp-research/43.png" alt><br>输入ip的时候注意把输入法切换为英文模式（通知栏显示ab），按#切换<br><img src="/2019/09/14/Qin-1sp-research/44.jpg" alt><br>然后进入系统更新<br><img src="/2019/09/14/Qin-1sp-research/45.jpg" alt><br>电脑上抓到了一条数据，点开一看<br>wtf？？？你的版本非法？？可还行？我机子全新刚拆封啊<br><img src="/2019/09/14/Qin-1sp-research/46.png" alt><br>修改下发送的数据，再发送到服务器，试了好多版本（1.2.1 1.1.x）都提示非法<br>最后试出来了1.0.6提示最新版本，但是并不给你包下载地址<br><img src="/2019/09/14/Qin-1sp-research/47.png" alt><br>1.0.4是最后一个给你下载地址（1.0.6）的版本<br><img src="/2019/09/14/Qin-1sp-research/48.png" alt><br>下载试试。。。只有几M可还行<br>看来通过抓包的方式是抓不到全量包了，不过我们知道了多亲ota服务器的目录结构<br>通过一顿操作成功获取到了全量包，不过是1.0.4版本的，但是这并不影响，因为我们还获取到了1.0.4版本以后的ota，只需要一个一个版本更新进去就行了<br>（操作方法这里就先略过吧，扒了下多亲ota服务器的sql数据库）<br><img src="/2019/09/14/Qin-1sp-research/49.png" alt><br>之前查询提示1.2.1版本非法可能是个bug<br>看一下全量包的目录结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">package.zip</span><br><span class="line">md5sum       # update.zip的md5校验文件</span><br><span class="line">update.zip   </span><br><span class="line">META-INF # 刷机脚本和签名文件存放目录</span><br><span class="line">recovery # 存放recovery差分文件</span><br><span class="line">system   # system分区文件</span><br><span class="line">boot.img # boot分区镜像</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><img src="/2019/09/14/Qin-1sp-research/50.png" alt><br>好吧并没有完整的recovery.img文件，但是有差分文件，我们可以通过boot.img来生成，因为这是1.0.4版本的系统包，我们需要先获取到最新版的boot.img<br>看一下ota包的结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">package.zip</span><br><span class="line">md5sum             # update.zip的md5校验文件</span><br><span class="line">update.zip   </span><br><span class="line">META-INF       # 刷机脚本和签名文件存放目录</span><br><span class="line">recovery       # 存放recovery差分文件</span><br><span class="line">patch          # 存放差分文件</span><br><span class="line">boot.img.p # boot.img差分文件</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><img src="/2019/09/14/Qin-1sp-research/51.png" alt><br>我们把boot.img和boot.img.p解压出来<br>除此之外还需要<code>META-INF/com/google/android/updater-script</code>里的内容<br>找到boot.img的那一行，把前面三个参数复制下来（选中的和前面两个）<br><img src="/2019/09/14/Qin-1sp-research/52.png" alt><br>在wsl中执行指令（因为我只找到了linux的applypatch程序）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ applypatch boot.img boot1.img 前面的参数(boot1.img的sha1) 中间的参数(boot1.img的字节数) 选中的参数(boot.img的sha1):boot.img.p</span><br></pre></td></tr></table></figure><p><img src="/2019/09/14/Qin-1sp-research/53.png" alt><br>只要没有在命令返回中看到<code>patch did not produce expected sha1</code>，那说明生成成功了，把boot.img和boot.img.p删除，boot1.img重命名为boot.img，对下一个版本重复以上步骤，直到最后一个版本<br>最终我们得到了一个最新的boot.img，接下来找到最新那个包里的<code>recovery/recovery-from-boot.p</code>，复制过来<br><img src="/2019/09/14/Qin-1sp-research/54.png" alt></p><ul><li>注意了，这里划重点，网上好多教程都是坑人的，有些rec不需要用到<code>install-recovery.sh</code>这个文件，具体看下面</li></ul><p>用文本编辑器打开，查看文件头<br>如果有<code>BSDIFF</code>字样就好整，直接执行下面的指令就行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ bspatch boot.img recovery.img recovery-from-boot.p</span><br></pre></td></tr></table></figure><p>如果有<code>IMGDIFF</code>字样(如下)<br><img src="/2019/09/14/Qin-1sp-research/55.png" alt><br>那需要继续提取<code>/recovery/etc/install-recovery.sh</code>和<code>/system/etc/recovery-resource.dat</code>(在全量包和系统里都可以找到)<br>用文本编辑器打开<code>install-recovery.sh</code><br>找到<code>applypatch</code>开头的一行，复制下来<br><img src="/2019/09/14/Qin-1sp-research/56.png" alt><br>把EMMC和绝对路径改成文件路径<br><code>applypatch -b /system/etc/recovery-resource.dat EMMC:/dev/block/platform/soc/by-name/boot:9979904:821bffe9268699430aece61933229132f882f1e9 EMMC:/dev/block/platform/soc/by-name/recovery 0a13745ae8d85762a03a0cddca7feb3c1aebce58 10479616 821bffe9268699430aece61933229132f882f1e9:/system/recovery-from-boot.p</code><br>改为<br><code>applypatch -b recovery-resource.dat boot.img recovery.img 0a13745ae8d85762a03a0cddca7feb3c1aebce58 10479616 821bffe9268699430aece61933229132f882f1e9:recovery-from-boot.p</code><br>因为用到了-b开关，所以我们就不能使用刚才的那个applypatch了，需要一个Android设备或者模拟器，连上电脑，推送这三个文件到<code>/data/local/tmp</code>，然后执行指令<br><img src="/2019/09/14/Qin-1sp-research/57.png" alt></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ adb push boot.img recovery-from-boot.p recovery-resource.dat /data/<span class="built_in">local</span>/tmp</span><br><span class="line">$ adb shell</span><br><span class="line">$ <span class="built_in">cd</span> /data/<span class="built_in">local</span>/tmp</span><br><span class="line">$ applypatch -b recovery-resource.dat boot.img recovery.img 0a13745ae8d85762a03a0cddca7feb3c1aebce58 10479616 821bffe9268699430aece61933229132f882f1e9:recovery-from-boot.p</span><br></pre></td></tr></table></figure><p>如果你看到<code>patch boot.img: Supporting patching EMMC targets only.</code>(如图)，那说明你的设备不支持这么玩，需要换个设备或者模拟器<br><img src="/2019/09/14/Qin-1sp-research/58.png" alt><br>我这里是使用<code>腾讯手游助手</code>弄好的，这个模拟器开发很方便，自带root，也没有多余的软件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ AndroidEmulator -engine VDI <span class="comment"># AndroidEmulator是腾讯手游助手的模拟器程序，在安装目录的ui文件夹下，一定要加-enging VDI用VDI引擎启动，否则用的是AOW引擎，会炸掉</span></span><br><span class="line">$ adb connect localhost:5555  <span class="comment"># 腾讯手游助手的默认adb侦听端口(如下图)，等待模拟器启动完成后再连接</span></span><br><span class="line">$ adb push boot.img recovery-from-boot.p recovery-resource.dat /data/<span class="built_in">local</span>/tmp</span><br><span class="line">$ adb shell</span><br><span class="line"><span class="comment"># cd /data/local/tmp          # 这里应该就默认给root权限了</span></span><br><span class="line"><span class="comment"># applypatch -b recovery-resource.dat boot.img recovery.img 0a13745ae8d85762a03a0cddca7feb3c1aebce58 10479616 821bffe9268699430aece61933229132f882f1e9:recovery-from-boot.p</span></span><br><span class="line"><span class="comment"># exit                        # 上一步出现&quot;patch boot.img: now xxxxxxx&quot;就说明生成成功了，可以退出shell了</span></span><br><span class="line">$ adb pull /data/<span class="built_in">local</span>/tmp/recovery.img</span><br></pre></td></tr></table></figure><p><img src="/2019/09/14/Qin-1sp-research/59.png" alt><br>如果一切顺利，你会看到类似如下的输出，文件夹中也会多出来一个recovery.img文件，这就是我们要的recovery了，其余的文件可以删除掉了<br><img src="/2019/09/14/Qin-1sp-research/60.png" alt></p><h2 id="破解Recovery签名验证"><a href="#破解Recovery签名验证" class="headerlink" title="破解Recovery签名验证"></a>破解Recovery签名验证</h2><p>用<code>bootimg</code>工具解包recovery.img</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ rename recovery.img boot.img <span class="comment"># 因为工具只认boot.img，所以重命名一下</span></span><br><span class="line">$ bootimg --unpack-bootimg</span><br></pre></td></tr></table></figure><p>一切顺利，你会看到类似如下的输出，文件夹下多出来一堆文件<br><img src="/2019/09/14/Qin-1sp-research/61.png" alt><br>文件结构大概是这样的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ramdisk.gz   # rec用到的一些系统文件</span><br><span class="line">boot.img     # 解包之前的文件，打包时会自动删</span><br><span class="line">boot-old.img # 同上，备份，可删</span><br><span class="line">initrd       # ramdisk.gz的解包</span><br><span class="line">sbin     # 存放recovery elf文件的目录</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>我们要修改的是<code>/initrd/sbin/recovery</code>这个文件<br>用IDA Pro (32-bit)打开(64-bit好像无法保存32位的elf)<br>等待IDA分析文件<br><img src="/2019/09/14/Qin-1sp-research/62.png" alt><br>点击左上角的<code>Search for text</code>按钮，搜索<code>signature</code><br><img src="/2019/09/14/Qin-1sp-research/63.png" alt><br><img src="/2019/09/14/Qin-1sp-research/64.png" alt><br>顺着箭头往上翻，找到最近的<code>CMP</code>，看到下面有个<code>BEQ</code>，这句就是跳转代码<br><img src="/2019/09/14/Qin-1sp-research/65.png" alt><br>普及一下arm指令集</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BNE: 标志寄存器中Z标志位不等于零时, 跳转到BNE后标签处</span><br><span class="line">BEQ(D0): 标志寄存器中Z标志位等于零时, 跳转到BEQ后标签处</span><br><span class="line">B(E7)：无条件跳转，一旦遇到一个 B 指令，ARM 处理器将立即跳转到给定的地址，从那里继续执行</span><br></pre></td></tr></table></figure><p>我们可以把<code>BEQ</code>修改为<code>BNE</code>，但是这样如果签名验证通过，就会挂掉(官方包无法安装)，所以我们最好是修改为无条件跳转指令<code>B</code><br>右键<code>BEQ</code>，切换到汇编文本窗口<br><img src="/2019/09/14/Qin-1sp-research/66.png" alt><br>找到刚才的<code>BEQ</code><br><img src="/2019/09/14/Qin-1sp-research/67.png" alt><br>右键，勾选<code>Synchronize with--Hex View 1</code>(如已勾选请跳过)<br><img src="/2019/09/14/Qin-1sp-research/68.png" alt><br>点击<code>Hex View</code>标签栏，选中<code>D0</code><br><img src="/2019/09/14/Qin-1sp-research/69.png" alt><br>点击左上角<code>Edit--Patch program--Change byte</code><br><img src="/2019/09/14/Qin-1sp-research/70.png" alt><br>将<code>D0</code>改成<code>E7</code><br><img src="/2019/09/14/Qin-1sp-research/71.png" alt><br>返回<code>Text View</code>标签栏发现<code>BEQ</code>改成了<code>B</code><br>同理，再次查询<code>signature</code>，继续修改，这里不再过多叙述<br><img src="/2019/09/14/Qin-1sp-research/72.png" alt><br>点击左上角<code>Edit--Patch program--Apply patches to input file</code><br><img src="/2019/09/14/Qin-1sp-research/73.png" alt><br>点击<code>OK</code>保存文件<br><img src="/2019/09/14/Qin-1sp-research/74.png" alt><br>最后关闭窗口，勾选<code>DON&#39;T SAVE the database</code>后再点击<code>OK</code><br><img src="/2019/09/14/Qin-1sp-research/75.png" alt><br>最后将更改打包进img</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ bootimg --repack-bootimg</span><br><span class="line">$ rename boot-new.img recovery.img</span><br></pre></td></tr></table></figure><p><img src="/2019/09/14/Qin-1sp-research/76.png" alt></p><h2 id="刷入修改后的Recovery"><a href="#刷入修改后的Recovery" class="headerlink" title="刷入修改后的Recovery"></a>刷入修改后的Recovery</h2><p>手机连接电脑，执行指令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ adb reboot bootloader</span><br><span class="line">$ fastboot flash recovery recovery.img</span><br></pre></td></tr></table></figure><p>刷入成功，机子并没有BootLoader锁<br><img src="/2019/09/14/Qin-1sp-research/77.png" alt><br>这里直接刷入了，按理说是应该先执行boot指令测试img的，但是因为是展讯的cpu，所以boot指令是废的（<a href="https://blog.csdn.net/bmw7bmw7/article/details/45392637">参考资料</a>）<br>这里需要注意，我们并不能直接重启，因为system里还有install-recovery.sh，一重启rec就会恢复为原版<br>所以我们需要在install-recovery.sh执行之前让他启动到recovery里，但是adb不会wating设备，fastboot这点做的就很好<br>两种选择：</p><ol><li>魔改adb让他检测不到设备时循环检测不退出</li><li>自己写个循环脚本</li></ol><p>我最终选择了第二个，为什么呢？因为我存放aosp源码的linux虚拟机所在的磁盘满了，无法启动，所以无法魔改adb<br>话不多说直接上代码吧</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@echo off</span><br><span class="line">adb kill-server</span><br><span class="line">adb start-server</span><br><span class="line">fastboot reboot</span><br><span class="line">:start</span><br><span class="line">adb reboot recovery</span><br><span class="line">if &quot;%errorlevel%&quot;&#x3D;&#x3D;&quot;0&quot; (</span><br><span class="line">goto break</span><br><span class="line">)</span><br><span class="line">goto start</span><br><span class="line">:break</span><br><span class="line">exit</span><br></pre></td></tr></table></figure><p>在控制台刷了一堆<code>error: no devices/emulators found</code>之后，手机黑屏重启进入了rec模式<br><img src="/2019/09/14/Qin-1sp-research/78.jpg" alt><br>正当我兴高采烈地去刷的时候，发现。。炸了。。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">E:failed to set up expected mounts for install; aborting</span><br><span class="line">Installation aborted.</span><br></pre></td></tr></table></figure><p><img src="/2019/09/14/Qin-1sp-research/79.jpg" alt><br>多次尝试之后，发现这只是个bug，多刷几次或者拔掉数据线就好了<br><img src="/2019/09/14/Qin-1sp-research/80.jpg" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Install from sdcard complete.</span><br></pre></td></tr></table></figure><p>大功告成，破解成功，重启进入系统安装试试水</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ adb install Coolapk.apk</span><br></pre></td></tr></table></figure><p><img src="/2019/09/14/Qin-1sp-research/81.png" alt><br>安装成功！<br><img src="/2019/09/14/Qin-1sp-research/82.jpg" alt><br><img src="/2019/09/14/Qin-1sp-research/83.jpg" alt></p><h2 id="后语"><a href="#后语" class="headerlink" title="后语"></a>后语</h2><p>至此，破解安装应用已完成，需要注意的是每次进入rec都需要遵循以下步骤：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ adb reboot bootloader</span><br><span class="line">$ fastboot flash recovery recovery.img</span><br></pre></td></tr></table></figure><p>然后执行那个循环脚本，不然进入的是官方rec<br>或者你可以直接把那个<code>install-recovery.sh</code>给搞掉，我懒的搞<br>也可以刷个<code>Magisk</code>或者<code>SuperSU</code>来root什么的，建议是最好不要直接修改system分区，因为炸了不好整<br>刷机包呢，你也可以使用bsdiff来让你的破解更加优雅（大雾）</p><h2 id="资源下载"><a href="#资源下载" class="headerlink" title="资源下载"></a>资源下载</h2><p><a href="http://cdn.meowcat.org/mlgmxyysd/storage/201909162236/Drivers.zip">驱动(请禁用驱动签名)</a><br><a href="http://cdn.meowcat.org/mlgmxyysd/storage/201909162236/Qin1sp_crack.zip">工具打包(不含驱动，手机打开adb模式连接电脑，运行crack.cmd)</a></p><h2 id="版权信息"><a href="#版权信息" class="headerlink" title="版权信息"></a>版权信息</h2><p>驱动来自SpreadTrum及Google<br>bootimg来自cofface<br>bsdiff&amp;bspatch来自<a href="http://www.daemonology.net/bsdiff/">http://www.daemonology.net/bsdiff/</a><br>applypatch来自<a href="https://github.com/airk000/Applypatch_for_Linux">https://github.com/airk000/Applypatch_for_Linux</a><br>recovery.img来自多亲，由MlgmXyysd修改</p><hr><p>友情提示：玩机有风险，刷机需谨慎，由刷机带来的一切后果本人概不负责<br>文章由MlgmXyysd撰写，转载请注明<a href="http://mlgmxyysd.meowcat.org/">http://mlgmxyysd.meowcat.org/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;最近看见了这个多亲1s+按键机，心血来潮弄个玩玩，第三天的下午快递送来了&lt;br&gt;&lt;img src=&quot;/2019/09/14/Qin-1sp-research/1.jpg&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="随笔" scheme="http://mlgmxyysd.meowcat.org/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="原创" scheme="http://mlgmxyysd.meowcat.org/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="Android" scheme="http://mlgmxyysd.meowcat.org/tags/Android/"/>
    
      <category term="玩机" scheme="http://mlgmxyysd.meowcat.org/tags/%E7%8E%A9%E6%9C%BA/"/>
    
      <category term="多亲" scheme="http://mlgmxyysd.meowcat.org/tags/%E5%A4%9A%E4%BA%B2/"/>
    
      <category term="技术" scheme="http://mlgmxyysd.meowcat.org/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
</feed>
